import { parser } from "./lezer.grammar";
import { syntaxTree } from "@codemirror/language"
import { SyntaxNode, NodeType, Tree } from "@lezer/common"


export class AutogeneratedComplete {
    private parsed: any;
    private parser: any;
    constructor(parsed: any) {
        this.parsed = parsed;
        this.parser = parser;
    }

    public static fromGrammarb64(grammarb64: string): AutogeneratedComplete {
        return AutogeneratedComplete.fromLezerGrammar(atob(grammarb64));
    }
    
    public static fromLezerGrammar(grammar: string): AutogeneratedComplete {
        return new AutogeneratedCompleteBuilder(grammar).build();
    }
}

interface TokenTrie {
    tokenName: string;
}

const START_TOKEN = "$";
class AutogeneratedCompleteBuilder {
    private grammar: string;
    private ruleDeclarations: Map<string, TokenTrie>;
    constructor(grammar: string) {
        this.grammar = grammar;
        this.ruleDeclarations = new Map<string, TokenTrie>();
    }

    public build(): AutogeneratedComplete {    
        let parsed = parser.parse(grammar)
        let declarations: SyntaxNode[] = [];
        let cursor = parsed.topNode.cursor();
        let hasNode = cursor.firstChild();
        while (hasNode) {
            console.log("Cursor node:", cursor.node);
            if (cursor.type.name === "RuleDeclaration") {
                declarations.push(cursor.node);
            };
            hasNode = cursor.nextSibling();
        }
        
        declarations.forEach(node => this.processRuleDeclarations(grammar, node));
        return new AutogeneratedComplete(parsed);
    }

    processRuleDeclarations(declaration: SyntaxNode) {
        let nameNode = declaration.firstChild();
        let bodyNode = declaration.lastChild();
        let name: string = this.grammar.substring(nameNode.from, nameNode.to);

        let choices = { tokenName: START_TOKEN, }; // First token by
        this.ruleDeclarations.set(name, choices);
    }
}
