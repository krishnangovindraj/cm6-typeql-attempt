import { parser } from "./lezer.grammar";
import { syntaxTree } from "@codemirror/language"
import { SyntaxNode, NodeType, Tree, TreeCursor } from "@lezer/common"


export class AutogeneratedComplete {
    private parsed: Tree;
    private ruleDeclarations: Map<string, TokenTrie>;
    constructor(parsed: Tree, ruleDeclarations: Map<string, TokenTrie>) {
        this.parsed = parsed;
        this.ruleDeclarations = ruleDeclarations
    }

    public static fromGrammarb64(grammarb64: string): AutogeneratedComplete {
        return AutogeneratedComplete.fromLezerGrammar(atob(grammarb64));
    }
    
    public static fromLezerGrammar(grammar: string): AutogeneratedComplete {
        return new AutogeneratedCompleteBuilder(grammar).build();
    }
}

interface TokenTrie {
    tokenName: string;
    next: TokenTrie[],
}

const START_TOKEN = "$";
class AutogeneratedCompleteBuilder {
    private grammar: string;
    private ruleDeclarations: Map<string, TokenTrie>;
    constructor(grammar: string) {
        this.grammar = grammar;
        this.ruleDeclarations = new Map<string, TokenTrie>();
    }

    public build(): AutogeneratedComplete {    
        let parsed = parser.parse(this.grammar);
        let declarations: SyntaxNode[] = [];
        let cursor = parsed.topNode.cursor();
        let hasNode = cursor.firstChild();
        while (hasNode) {
            if (cursor.type.name === "RuleDeclaration") {
                declarations.push(cursor.node);
            };
            hasNode = cursor.nextSibling();
        }
        
        declarations.forEach(node => this.processRuleDeclarations(node));
        return new AutogeneratedComplete(parsed, this.ruleDeclarations);
    }

    processRuleDeclarations(declaration: SyntaxNode) {
        let nameNode = declaration.firstChild!;
        let name: string = this.grammar.substring(nameNode.from, nameNode.to);
        let bodyNode = declaration.lastChild!;
        assertNodeType(["Body"], bodyNode.type.name);
        let choices = this.visitExpression(bodyNode.firstChild!.nextSibling!);
        let trieNode = { tokenName: START_TOKEN, next: choices };
        this.ruleDeclarations.set(name, trieNode);
    }
    
    visitExpression(expressionNode: SyntaxNode): TokenTrie[] {
        console.log("Visiting expression node:", expressionNode);
        switch (expressionNode.type.name) {
            case "Sequence": return this.visitSequence(expressionNode);
            case "Choice":  return this.visitChoice(expressionNode);
            case "RuleName": todo
            case "Literal": todo;

            // Probably handle them all in the same way
            
            case "CharClass": todo
            case "CharSet": todo;
            case "AnyChar": todo;
            case "InvertedCharSet": todo;
            case "Repeat": todo;
            case "Optional": todo; // Probably the same way again
            case "Repeat1": todo;
            
            case "InlineRule": todo;
            case "ParenExpression": todo;
            case "Specialization": throw new Error("Specialization not supported in autocomplete");
        }
    }
    
    visitSequence(sequenceNode: SyntaxNode): TokenTrie {
        assertNodeType(["Sequence"], sequenceNode.type.name);
        let choices: TokenTrie[] = [];
        // let cursor = expressionNode.cursor();
        // let hasNode = cursor.firstChild();
        // while (hasNode) {
        //     if (cursor.type.name === "Choice") {
        //         choices.push(...this.visitChoice(cursor.node));
        //     }
        //     hasNode = cursor.nextSibling();
        // }
        return choices;
    }

    visitChoice(choiceNode: SyntaxNode): TokenTrie[] {
        assertNodeType(["Choice"], choiceNode.type.name);
        let choices: TokenTrie[] = [];
 
        return choices;
    }
}

function assertNodeType(expected: string[], found: string) {
    if (!expected.includes(found)) {
        throw new Error(`Expected node type to be ${expected}, but found: ${found}`);
    }
}
