import { parser } from "./lezer.grammar";
import { syntaxTree } from "@codemirror/language"
import { SyntaxNode, NodeType, Tree, TreeCursor } from "@lezer/common"


export class AutogeneratedComplete {
    private parsed: Tree;
    private ruleDeclarations: Map<string, TokenTrie>;
    constructor(parsed: Tree, ruleDeclarations: Map<string, TokenTrie>) {
        this.parsed = parsed;
        this.ruleDeclarations = ruleDeclarations
    }

    public static fromGrammarb64(grammarb64: string): AutogeneratedComplete {
        return AutogeneratedComplete.fromLezerGrammar(atob(grammarb64));
    }
    
    public static fromLezerGrammar(grammar: string): AutogeneratedComplete {
        return new AutogeneratedCompleteBuilder(grammar).build();
    }
}

interface TokenTrie {
    tokenName: string;
    next: TokenTrie[],
}

const START_TOKEN = "$";
class AutogeneratedCompleteBuilder {
    private grammar: string;
    private ruleDeclarations: Map<string, TokenTrie>;
    constructor(grammar: string) {
        this.grammar = grammar;
        this.ruleDeclarations = new Map<string, TokenTrie>();
    }

    public build(): AutogeneratedComplete {    
        let parsed = parser.parse(this.grammar);
        let declarations: SyntaxNode[] = [];
        let cursor = parsed.topNode.cursor();
        let hasNode = cursor.firstChild();
        while (hasNode) {
            if (cursor.type.name === "RuleDeclaration") {
                declarations.push(cursor.node);
            };
            hasNode = cursor.nextSibling();
        }
        
        declarations.forEach(node => this.processRuleDeclarations(node));
        return new AutogeneratedComplete(parsed, this.ruleDeclarations);
    }

    processRuleDeclarations(declaration: SyntaxNode) {
        let nameNode = declaration.firstChild!;
        let name: string = this.grammar.substring(nameNode.from, nameNode.to);
        let bodyNode = declaration.lastChild!;
        let choices = new TokenTrieBuilder(this.grammar, bodyNode).build();
        this.ruleDeclarations.set(name, choices);
    }
}

function assertNodeType(expected: string[], found: string) {
    if (!expected.includes(found)) {
        throw new Error(`Expected node type to be ${expected}, but found: ${found}`);
    }
}

// class TokenTrieBuilder {
//     private atNode: SyntaxNode;
//     private grammar: string;
//     constructor(grammar: string, atNode: SyntaxNode) {
//         this.atNode = atNode;
//         this.grammar = grammar;
//     }

//     build(): TokenTrie {
//         let cursor = this.atNode.cursor();
//         assertNodeType(["Body"], cursor.type.name);
//         cursor.firstChild();
//         let next = this.visitRule(cursor);
//         return { tokenName: START_TOKEN, next: next };
//     }

//     visitRule(cursor: TreeCursor): TokenTrie[] {
//         assertNodeType(["{", "("], cursor.type.name);
//         let _openSymbol = cursor.type.name;
//         let tries = [];
//         do {
//             cursor.nextSibling();
//             let sequence = this.visitSequence(cursor);
//             if (sequence != null) {
//                 tries.push(...sequence);
//             }
//             assertNodeType(["}", ")", "|"], cursor.type.name);
//         } while (cursor.node.type.name === "|");
        
//         assertNodeType(["}", ")"], cursor.type.name);
        
//         return tries;

//     }

//     visitSequence(cursor: TreeCursor): TokenTrie[] {
//         switch (cursor.type.name) {
//             case "}":
//             case ")":
//             case "|": {
//                 return  [];
//             }
//             case "{":
//             case "(": {
//                 return this.visitRule(cursor);
//             }
//             default: { // Leaf
//                 console.log("Visiting leaf node: " + cursor.type.name);
//                 let trie = { 
//                     tokenName: this.grammar.substring(cursor.from, cursor.to),
//                     next: []
//                 };
//                 cursor.nextSibling();
//                 let nextTries = this.visitSequence(cursor);
//                 this.joinTries([trie], nextTries);
//                 return [trie];
//             }
//         }
//     }

//     findEnds(tries: TokenTrie[]) : TokenTrie[] {
//         return tries.flatMap(trie => {
//             if (trie.next.length === 0) {
//                 return [];
//             } else {
//                 return this.findEnds(trie.next);
//             }
//         });
//     }

//     joinTries(before: TokenTrie[], after: TokenTrie[]) {
//         before.forEach(beforeTrie => {
//             if (beforeTrie.next.length !== 0) { // debug assert
//                 throw new Error("Expected a token trie to have no next tokens, but found: " + beforeTrie.next.length);
//             }
//             beforeTrie.next.push(...after);
//         });
//     }
// }