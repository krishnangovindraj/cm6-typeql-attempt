@top QueryPipeline { Pipeline }
@skip { whitespace | linecomment }


//QueryPipelinePreambled {
//  Preamble* Pipeline
//}

//Pipeline {
//  QueryStage+ QueryStageTerminal?
//}


//Preamble {
//  WITH DefinitionFunction
//}

Pipeline {
  QueryStage+ END SEMICOLON
}
QueryStage {
  ClauseMatch |
  ClauseInsert |
  ClausePut |
  ClauseUpdate |
  ClauseDelete // |
  // OperatorStream
}

//QueryStageTerminal {
//  ClauseFetch SEMICOLON
//}

// Stages
ClauseMatch {
  MATCH Patterns
}


ClauseInsert {
  INSERT (StatementThing SEMICOLON)+
//  INSERT (StatementThing SEMICOLON | StatementAssignment SEMICOLON)+
}

ClausePut {
 PUT (StatementThing SEMICOLON)+
}

ClauseUpdate {
 UPDATE (StatementThing SEMICOLON)+
}

ClauseDelete {
 DELETE (StatementDeletable SEMICOLON)+
}

// OperatorStream {
//  OperatorSelect |
//  OperatorSort |
//  OperatorDistinct |
//  OperatorOffset |
//  OperatorLimit |
//  OperatorRequire |
//  OperatorReduce
// }

//OperatorSelect {
//  SELECT VARs SEMICOLON
//}

//OperatorSort {
//  SORT VAROrder (COMMA VAROrder)* SEMICOLON
//}

//OperatorOffset {
//  OFFSET INTEGERLITERAL SEMICOLON
//}

//OperatorLimit {
//  LIMIT INTEGERLITERAL SEMICOLON
//}

//OperatorRequire {
//  REQUIRE VARs SEMICOLON
//}

//OperatorDistinct {
//  DISTINCT SEMICOLON
//}

//OperatorReduce {
//  REDUCE ReduceAssign (COMMA ReduceAssign)* (GROUPBY VARs)? SEMICOLON
//}

// Stage arguments
//VAROrder {
//  VAR ORDER?
//}

//ReduceAssign {
//  (ReduceAssignmentVAR ASSIGN Reducer)
//}

//ReduceAssignmentVAR {
//  VAROptional | VAR
//}

//Reducer {
//  COUNT (PARENOPEN VAR PARENCLOSE)? |
//  MAX PARENOPEN VAR PARENCLOSE |
//  MIN PARENOPEN VAR PARENCLOSE |
//  MEAN PARENOPEN VAR PARENCLOSE |
//  MEDIAN PARENOPEN VAR PARENCLOSE |
//  STD PARENOPEN VAR PARENCLOSE |
//  SUM PARENOPEN VAR PARENCLOSE |
//  LIST PARENOPEN VAR PARENCLOSE
//}
  
// Patterns
Patterns {
  (Pattern SEMICOLON)+
}

Pattern {
  Statement |
  PatternDisjunction |
  PatternConjunction |
  PatternNegation |
  PatternTry
}

PatternConjunction {
  CURLYOPEN Patterns CURLYCLOSE
}

PatternDisjunction {
  CURLYOPEN Patterns CURLYCLOSE (OR CURLYOPEN Patterns CURLYCLOSE)+
}

PatternNegation {
  NOT CURLYOPEN Patterns CURLYCLOSE
}

PatternTry {
 TRY CURLYOPEN Patterns CURLYCLOSE
}

StatementDeletable {
  HAS? VAR OF VAR |
  LINKS? Relation OF VAR |
  VAR
}

StatementType {
  KIND TypeRef (TypeConstraint (COMMA TypeConstraint)* COMMA?)?
}

TypeConstraint {
  TypeConstraintBase // Annotations?
}

TypeConstraintBase {
  SubConstraint |
  ValueTypeConstraint |
  LabelConstraint |
  OwnsConstraint |
  RelatesConstraint |
  PlaysConstraint
}

SubConstraint {
  SUB TypeRef
}

ValueTypeConstraint {
  VALUEKEYWORD ValueType
}

LabelConstraint {
  LABELKEYWORD LABEL // (LabelScoped | LABEL)
}


OwnsConstraint {
  OWNS TypeRef
  // | OWNS TypeRefList
}

RelatesConstraint {
  RELATES TypeRef (AS TypeRef)?
  // | RELATES TypeRefList (AS TypeRefList)?
}

PlaysConstraint {
  PLAYS TypeRef
}

Statement {
  // StatementSingle |
  StatementType |
  StatementThing
}

StatementThing {
  VAR COMMA? ThingConstraintList
  // ThingRelationAnonymous (COMMA? ThingConstraintList)?
}

// ThingRelationAnonymous {
//   TypeRef? Relation
// }

ThingConstraintList {
  ThingConstraint (COMMA ThingConstraint)* COMMA?
}

ThingConstraint {
  IsaConstraint |
  IidConstraint |
  HasConstraint |
  LinksConstraint
}

IsaConstraint {
  ISA TypeRef
  // ISA TypeRef  (Relation | Expression | ValueLiteral | ExpressionStruct | Comparison)?
}

IidConstraint {
  IID IID_VALUE
}

HasConstraint {
  HAS TypeRef VAR |
  HAS TypeRef ValueLiteral |
  HAS VAR
}

LinksConstraint {
  LINKS Relation
}

Relation {
  PARENOPEN RolePlayer (COMMA RolePlayer)* COMMA? PARENCLOSE
}

RolePlayer {
  // TypeRefList COLON VAR |
  TypeRef COLON VAR |
  VAR
}

// TypeRefList {
//   TypeRef SQBRACKETOPEN SQBRACKETCLOSE
// }

TypeRef {
  // LabelScoped |
  LABEL |
  VAR
}

// LabelScoped {
//   LABEL COLON LABEL
// }


ValueLiteral {
  STRINGLITERAL |
  INTEGERLITERAL
  // TODO
}

ValueType {
  BOOLEAN |
  INTEGER |
  DOUBLE |
  DECIMAL |
  DATETIMETZ |
  DATETIME |
  DATE |
  DURATION |
  STRING
}

@tokens {
  VAR { DOLLAR $[a-zA-Z_\-0-9]+ }
  LABEL { $[a-zA-Z_\-0-9]+ }
  DOLLAR { "$" }

  // WITH { "with" }
  MATCH { "match" }
  INSERT { "insert" }
  PUT { "put" }
  UPDATE { "update" }
  DELETE { "delete" }
  // SELECT { "select" }
  // SORT { "sort" }
  // OFFSET { "offset" }
  // LIMIT { "limit" }
  // REQUIRE { "require" }
  // DISTINCT { "distinct" }
  // REDUCE { "reduce" }
  // GROUPBY { "groupby" }
  // COUNT { "count" }
  END { "end" }

  // MAX { "max" }
  // MIN { "min" }
  // MEAN { "mean" }
  // MEDIAN { "median" }
  // STD { "std" }
  // SUM { "sum" }
  // LIST { "list" }
  // ORDER { ASCENDINGORDER | DESCENDINGORDER }
  // ASCENDINGORDER { "asc" }
  // DESCENDINGORDER { "desc" }
  // ASSIGN { "=" }
  
  // Patterns
  OR { "or" }
  NOT { "not" }
  TRY { "try" }
  
  // Statements
  HAS { "has" }
  ISA { "isa" }
  LINKS { "links" }
  IID { "iid" }

  SUB { "sub" }
  VALUEKEYWORD { "value" }
  LABELKEYWORD { "label" }
  OWNS { "owns" }
  RELATES { "relates" }
  PLAYS { "plays" }

  KIND { "kind" }

  OF { "of" }
  AS { "as" }
  // FROM { "from" }

  // ValueTypes 
  BOOLEAN { "boolean" }
  INTEGER { "integer" }
  DOUBLE { "double" }
  DECIMAL { "decimal" }
  DATETIMETZ { "datetime-tz" }
  DATETIME { "datetime" }
  DATE { "date" }
  DURATION { "duration" }
  STRING { "string" }
  
  
  // Punctuation
  SEMICOLON { ";" }
  COMMA { "," }
  COLON { ":" }
  PARENOPEN { "(" }
  PARENCLOSE { ")" }
  CURLYOPEN { "{" }
  CURLYCLOSE { "}" }
  // SQBRACKETOPEN { "[" }
  // SQBRACKETCLOSE { "]" }

  //@precedence { ASCENDINGORDER, DESCENDINGORDER }

  // Literals
  IID_VALUE { "0x" $[0-9a-fA-F]+ }

  STRINGLITERAL { '"' (!["\\] | "\\" _)* '"' }
  INTEGERLITERAL { "-"? $[0-9]+ }
  
  linecomment { "#" ![\n]* }
  whitespace { $[ \t\n\r]+ }
}